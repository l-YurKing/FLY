#include "bsp_LC307.h"
#include "usart.h"
#include <string.h>
#include <stdio.h>
uint8_t g_lost_pos_dev = 0;

//选择是否开启串口输出调试功能
#define LC307_DEBUG_LEVEL 1

//串口调试
#if (LC307_DEBUG_LEVEL > 0U)
#define  LC307_Log(...)   do { \
                            printf(__VA_ARGS__); \
} while (0)
#else
#define LC307_Log(...) do {} while (0)
#endif

UART_HandleTypeDef* OpticalFlowSerial = &huart3;

//存放光流原始数据的长度和数据
#define LC307_BufferLen 28
static uint8_t LC307OriBuffer[LC307_BufferLen];


//光流数据操作接口
static void LC307_SendData(uint8_t *data, uint16_t len)
{
	HAL_UART_Transmit(OpticalFlowSerial,data,len,50);
}

static void LC307_RecvData(uint8_t *data, uint16_t len)
{
	HAL_UART_Receive(OpticalFlowSerial,data,len,50);
}


//启动数据接收
static void start_LC307_dma_recv(void)
{
	HAL_UARTEx_ReceiveToIdle_DMA(OpticalFlowSerial,LC307OriBuffer,LC307_BufferLen);
}

//关闭数据接收
static void stop_dma_recv(void)
{
	HAL_UART_DMAStop(OpticalFlowSerial);
}

//光流数据配置表
const static uint8_t tab_BF3901_60hz[] = {
0x12, 0x80, 0x11, 0x30, 0x1b, 0x06, 0x6b, 0x43, 0x12, 0x20, 0x3a, 0x00, 0x15, 0x02, 0x62, 0x81, 0x08, 0xa0, 0x06, 0x68, 0x2b, 0x20, 0x92, 0x25, 0x27, 0x97, 0x17, 0x01, 0x18, 0x79,
0x19, 0x00, 0x1a, 0xa0, 0x03, 0x00, 0x13, 0x00, 0x01, 0x13, 0x02, 0x20, 0x87, 0x16, 0x8c, 0x01, 0x8d, 0xcc, 0x13, 0x07, 0x33, 0x10, 0x34, 0x1d, 0x35, 0x46, 0x36, 0x40, 0x37, 0xa4,
0x38, 0x7c, 0x65, 0x46, 0x66, 0x46, 0x6e, 0x20, 0x9b, 0xa4, 0x9c, 0x7c, 0xbc, 0x0c, 0xbd, 0xa4, 0xbe, 0x7c, 0x20, 0x09, 0x09, 0x03, 0x72, 0x2f, 0x73, 0x2f, 0x74, 0xa7, 0x75, 0x12,
0x79, 0x8d, 0x7a, 0x00, 0x7e, 0xfa, 0x70, 0x0f, 0x7c, 0x84, 0x7d, 0xba, 0x5b, 0xc2, 0x76, 0x90, 0x7b, 0x55, 0x71, 0x46, 0x77, 0xdd, 0x13, 0x0f, 0x8a, 0x10, 0x8b, 0x20, 0x8e, 0x21,
0x8f, 0x40, 0x94, 0x41, 0x95, 0x7e, 0x96, 0x7f, 0x97, 0xf3, 0x13, 0x07, 0x24, 0x58, 0x97, 0x48, 0x25, 0x08, 0x94, 0xb5, 0x95, 0xc0, 0x80, 0xf4, 0x81, 0xe0, 0x82, 0x1b, 0x83, 0x37,
0x84, 0x39, 0x85, 0x58, 0x86, 0xff, 0x89, 0x15, 0x8a, 0xb8, 0x8b, 0x99, 0x39, 0x98, 0x3f, 0x98, 0x90, 0xa0, 0x91, 0xe0, 0x40, 0x20, 0x41, 0x28, 0x42, 0x26, 0x43, 0x25, 0x44, 0x1f,
0x45, 0x1a, 0x46, 0x16, 0x47, 0x12, 0x48, 0x0f, 0x49, 0x0d, 0x4b, 0x0b, 0x4c, 0x0a, 0x4e, 0x08, 0x4f, 0x06, 0x50, 0x06, 0x5a, 0x56, 0x51, 0x1b, 0x52, 0x04, 0x53, 0x4a, 0x54, 0x26,
0x57, 0x75, 0x58, 0x2b, 0x5a, 0xd6, 0x51, 0x28, 0x52, 0x1e, 0x53, 0x9e, 0x54, 0x70, 0x57, 0x50, 0x58, 0x07, 0x5c, 0x28, 0xb0, 0xe0, 0xb1, 0xc0, 0xb2, 0xb0, 0xb3, 0x4f, 0xb4, 0x63,
0xb4, 0xe3, 0xb1, 0xf0, 0xb2, 0xa0, 0x55, 0x00, 0x56, 0x40, 0x96, 0x50, 0x9a, 0x30, 0x6a, 0x81, 0x23, 0x33, 0xa0, 0xd0, 0xa1, 0x31, 0xa6, 0x04, 0xa2, 0x0f, 0xa3, 0x2b, 0xa4, 0x0f,
0xa5, 0x2b, 0xa7, 0x9a, 0xa8, 0x1c, 0xa9, 0x11, 0xaa, 0x16, 0xab, 0x16, 0xac, 0x3c, 0xad, 0xf0, 0xae, 0x57, 0xc6, 0xaa, 0xd2, 0x78, 0xd0, 0xb4, 0xd1, 0x00, 0xc8, 0x10, 0xc9, 0x12,
0xd3, 0x09, 0xd4, 0x2a, 0xee, 0x4c, 0x7e, 0xfa, 0x74, 0xa7, 0x78, 0x4e, 0x60, 0xe7, 0x61, 0xc8, 0x6d, 0x70, 0x1e, 0x39, 0x98, 0x1a, 0x9d, 0xf0
};

//光流模块错误码
#define xor_err 1
#define ack_err 2

//光流模块初始化标志位
static uint8_t LC307_InitFlag = 0;

uint8_t Opf_LC307_Init(void)
{
	start_LC307_dma_recv();
	
	uint32_t wait_i=0;
	for(wait_i=0;wait_i<100;wait_i++)
	{
		HAL_Delay(15);
	}

	//若存在数据包则说明已经完成初始化,直接退出
	if( LC307_InitFlag )  
	{
		return 0;
	}
	else
	{	//不存在数据包
		USART3->DR;
	}
	
	stop_dma_recv();
	
    uint8_t step1_initbuf[7] = {0xAA,0xAB,0x96,0x26,0xbc,0x50,0x5C};
    uint8_t feedbackbuf[3] = {0};

    //发送步骤1配置
    LC307_SendData(step1_initbuf,7);

    //检查反馈信息是否正确
    LC307_RecvData(feedbackbuf,3);
	
    if(((feedbackbuf[0]^feedbackbuf[1]) != feedbackbuf[2])) 
	{
		g_lost_pos_dev=1;
		return xor_err; //校验出错
	}

    if(feedbackbuf[1] != 0x00) 
	{
		g_lost_pos_dev=1;
		return ack_err; //芯片返回值不对
	}
    
    //step2配置,根据配置表进行参数配置
    //配置格式：0xBB 0xDC 地址 数据 异或校验(除去帧头)
    for(uint16_t i=0;i<sizeof(tab_BF3901_60hz)/sizeof(uint8_t);i+=2)
    {
        //发送配置指令
        uint8_t buf[5] = {0xBB, 0xDC, tab_BF3901_60hz[i], tab_BF3901_60hz[i+1],0};
        buf[4] = (buf[1]^buf[2]^buf[3]);
        LC307_SendData(buf,5);

        //检查反馈信息是否正确
        LC307_RecvData(feedbackbuf,3);

        if(((feedbackbuf[0]^feedbackbuf[1]) != feedbackbuf[2])) 
		{
			g_lost_pos_dev=1;
			return xor_err; //校验出错
		}
                
        if(feedbackbuf[1] != 0x00) 
		{
			g_lost_pos_dev=1;
			return ack_err; //芯片返回值不对
		}
		        
    }

    //step3,关闭配置指令
    uint8_t closecfg = 0xDD;
    LC307_SendData(&closecfg,1);
	LC307_InitFlag = 1;
	
	//启动光流DMA接收
	start_LC307_dma_recv();

    return 0;
}

// 异或校验函数：返回异或校验结果
static uint8_t XOR_Checksum(const uint8_t *data, uint16_t length) {
    uint8_t xor_result = 0;
    for (uint16_t i = 0; i < length; i++) {
        xor_result ^= data[i];  // 累计异或
    }
    return xor_result;
}

//1帧光流数据内容
#pragma pack(1)
typedef struct{
	uint8_t head1;
	uint8_t bufcount;
	short flowX;
	short flowY;
	uint16_t timespan;
	uint16_t distance;
	uint8_t quality;
	uint8_t version;
	uint8_t XORSum;
	uint8_t end;
}OpticalFlowFrame_t;
#pragma pack()

//1帧光流数据,用于存放解析后的数据
static OpticalFlowFrame_t opfRecv_Frame = { 0 };

static float speed[2]={0};

__weak void getOpticalFlowResult_Callback(float* buf)
{

}


//频率检测
//#include "bsp_RTOSdebug.h"
//static pRtosDebugInterface_t debug = &RTOSTaskDebug;
//static RtosDebugPrivateVar debugpriv = { 0 };
//static uint8_t freq = 0;


//光流数据处理回调函数 光流速度50Hz
void LC307_Callback(uint16_t size)
{
	if( size==14 && LC307OriBuffer[0]==0xFE ) //检查数据量与帧头是否正确
	{
		//数据正确性异或校验
		if( LC307OriBuffer[12] == XOR_Checksum(&LC307OriBuffer[2],10) )
		{
			LC307_InitFlag = 1;		
			memcpy(&opfRecv_Frame,LC307OriBuffer,sizeof(OpticalFlowFrame_t));
			
			//1.0f为将来要写入的高度,单位米
			speed[0] = 1.0f * (float)opfRecv_Frame.flowX;
			speed[1] = 1.0f * (float)opfRecv_Frame.flowY; //单位 m/s
			
			//触发回调函数
			getOpticalFlowResult_Callback(speed);
			
			//计算光流的频率
//			freq = debug->UpdateFreq(&debugpriv);	
		}
	}
	//重新启动DMA接收
	start_LC307_dma_recv();
}
